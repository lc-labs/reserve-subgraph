// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class NewVaultSet extends ethereum.Event {
  get params(): NewVaultSet__Params {
    return new NewVaultSet__Params(this);
  }
}

export class NewVaultSet__Params {
  _event: NewVaultSet;

  constructor(event: NewVaultSet) {
    this._event = event;
  }

  get oldVault(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newVault(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class OwnershipTransferred extends ethereum.Event {
  get params(): OwnershipTransferred__Params {
    return new OwnershipTransferred__Params(this);
  }
}

export class OwnershipTransferred__Params {
  _event: OwnershipTransferred;

  constructor(event: OwnershipTransferred) {
    this._event = event;
  }

  get previousOwner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get newOwner(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class AssetManager__auctionsResult {
  value0: Address;
  value1: Address;
  value2: BigInt;
  value3: BigInt;
  value4: BigInt;
  value5: BigInt;
  value6: i32;
  value7: boolean;

  constructor(
    value0: Address,
    value1: Address,
    value2: BigInt,
    value3: BigInt,
    value4: BigInt,
    value5: BigInt,
    value6: i32,
    value7: boolean
  ) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
    this.value3 = value3;
    this.value4 = value4;
    this.value5 = value5;
    this.value6 = value6;
    this.value7 = value7;
  }

  toMap(): TypedMap<string, ethereum.Value> {
    let map = new TypedMap<string, ethereum.Value>();
    map.set("value0", ethereum.Value.fromAddress(this.value0));
    map.set("value1", ethereum.Value.fromAddress(this.value1));
    map.set("value2", ethereum.Value.fromUnsignedBigInt(this.value2));
    map.set("value3", ethereum.Value.fromUnsignedBigInt(this.value3));
    map.set("value4", ethereum.Value.fromUnsignedBigInt(this.value4));
    map.set("value5", ethereum.Value.fromUnsignedBigInt(this.value5));
    map.set(
      "value6",
      ethereum.Value.fromUnsignedBigInt(BigInt.fromI32(this.value6))
    );
    map.set("value7", ethereum.Value.fromBoolean(this.value7));
    return map;
  }
}

export class AssetManager extends ethereum.SmartContract {
  static bind(address: Address): AssetManager {
    return new AssetManager("AssetManager", address);
  }

  approvedFiatcoins(): Array<Address> {
    let result = super.call(
      "approvedFiatcoins",
      "approvedFiatcoins():(address[])",
      []
    );

    return result[0].toAddressArray();
  }

  try_approvedFiatcoins(): ethereum.CallResult<Array<Address>> {
    let result = super.tryCall(
      "approvedFiatcoins",
      "approvedFiatcoins():(address[])",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddressArray());
  }

  auctions(param0: BigInt): AssetManager__auctionsResult {
    let result = super.call(
      "auctions",
      "auctions(uint256):(address,address,uint256,uint256,uint256,uint256,uint8,bool)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );

    return new AssetManager__auctionsResult(
      result[0].toAddress(),
      result[1].toAddress(),
      result[2].toBigInt(),
      result[3].toBigInt(),
      result[4].toBigInt(),
      result[5].toBigInt(),
      result[6].toI32(),
      result[7].toBoolean()
    );
  }

  try_auctions(
    param0: BigInt
  ): ethereum.CallResult<AssetManager__auctionsResult> {
    let result = super.tryCall(
      "auctions",
      "auctions(uint256):(address,address,uint256,uint256,uint256,uint256,uint8,bool)",
      [ethereum.Value.fromUnsignedBigInt(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      new AssetManager__auctionsResult(
        value[0].toAddress(),
        value[1].toAddress(),
        value[2].toBigInt(),
        value[3].toBigInt(),
        value[4].toBigInt(),
        value[5].toBigInt(),
        value[6].toI32(),
        value[7].toBoolean()
      )
    );
  }

  baseFactor(): BigInt {
    let result = super.call("baseFactor", "baseFactor():(int192)", []);

    return result[0].toBigInt();
  }

  try_baseFactor(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("baseFactor", "baseFactor():(int192)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  doAuctions(): i32 {
    let result = super.call("doAuctions", "doAuctions():(uint8)", []);

    return result[0].toI32();
  }

  try_doAuctions(): ethereum.CallResult<i32> {
    let result = super.tryCall("doAuctions", "doAuctions():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  fromBUs(BUs: BigInt): BigInt {
    let result = super.call("fromBUs", "fromBUs(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(BUs)
    ]);

    return result[0].toBigInt();
  }

  try_fromBUs(BUs: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall("fromBUs", "fromBUs(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(BUs)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  fullyCapitalized(): boolean {
    let result = super.call(
      "fullyCapitalized",
      "fullyCapitalized():(bool)",
      []
    );

    return result[0].toBoolean();
  }

  try_fullyCapitalized(): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "fullyCapitalized",
      "fullyCapitalized():(bool)",
      []
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  main(): Address {
    let result = super.call("main", "main():(address)", []);

    return result[0].toAddress();
  }

  try_main(): ethereum.CallResult<Address> {
    let result = super.tryCall("main", "main():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  owner(): Address {
    let result = super.call("owner", "owner():(address)", []);

    return result[0].toAddress();
  }

  try_owner(): ethereum.CallResult<Address> {
    let result = super.tryCall("owner", "owner():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  pastVaults(param0: BigInt): Address {
    let result = super.call("pastVaults", "pastVaults(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toAddress();
  }

  try_pastVaults(param0: BigInt): ethereum.CallResult<Address> {
    let result = super.tryCall("pastVaults", "pastVaults(uint256):(address)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  toBUs(amount: BigInt): BigInt {
    let result = super.call("toBUs", "toBUs(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBigInt();
  }

  try_toBUs(amount: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall("toBUs", "toBUs(uint256):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  vault(): Address {
    let result = super.call("vault", "vault():(address)", []);

    return result[0].toAddress();
  }

  try_vault(): ethereum.CallResult<Address> {
    let result = super.tryCall("vault", "vault():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }
}

export class ConstructorCall extends ethereum.Call {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }

  get main_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get vault_(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get owner_(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get approvedCollateral_(): Array<Address> {
    return this._call.inputValues[3].value.toAddressArray();
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class AccumulateCall extends ethereum.Call {
  get inputs(): AccumulateCall__Inputs {
    return new AccumulateCall__Inputs(this);
  }

  get outputs(): AccumulateCall__Outputs {
    return new AccumulateCall__Outputs(this);
  }
}

export class AccumulateCall__Inputs {
  _call: AccumulateCall;

  constructor(call: AccumulateCall) {
    this._call = call;
  }
}

export class AccumulateCall__Outputs {
  _call: AccumulateCall;

  constructor(call: AccumulateCall) {
    this._call = call;
  }
}

export class ApproveCollateralCall extends ethereum.Call {
  get inputs(): ApproveCollateralCall__Inputs {
    return new ApproveCollateralCall__Inputs(this);
  }

  get outputs(): ApproveCollateralCall__Outputs {
    return new ApproveCollateralCall__Outputs(this);
  }
}

export class ApproveCollateralCall__Inputs {
  _call: ApproveCollateralCall;

  constructor(call: ApproveCollateralCall) {
    this._call = call;
  }

  get collateral(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class ApproveCollateralCall__Outputs {
  _call: ApproveCollateralCall;

  constructor(call: ApproveCollateralCall) {
    this._call = call;
  }
}

export class BaseFactorCall extends ethereum.Call {
  get inputs(): BaseFactorCall__Inputs {
    return new BaseFactorCall__Inputs(this);
  }

  get outputs(): BaseFactorCall__Outputs {
    return new BaseFactorCall__Outputs(this);
  }
}

export class BaseFactorCall__Inputs {
  _call: BaseFactorCall;

  constructor(call: BaseFactorCall) {
    this._call = call;
  }
}

export class BaseFactorCall__Outputs {
  _call: BaseFactorCall;

  constructor(call: BaseFactorCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class CollectRevenueCall extends ethereum.Call {
  get inputs(): CollectRevenueCall__Inputs {
    return new CollectRevenueCall__Inputs(this);
  }

  get outputs(): CollectRevenueCall__Outputs {
    return new CollectRevenueCall__Outputs(this);
  }
}

export class CollectRevenueCall__Inputs {
  _call: CollectRevenueCall;

  constructor(call: CollectRevenueCall) {
    this._call = call;
  }
}

export class CollectRevenueCall__Outputs {
  _call: CollectRevenueCall;

  constructor(call: CollectRevenueCall) {
    this._call = call;
  }
}

export class DoAuctionsCall extends ethereum.Call {
  get inputs(): DoAuctionsCall__Inputs {
    return new DoAuctionsCall__Inputs(this);
  }

  get outputs(): DoAuctionsCall__Outputs {
    return new DoAuctionsCall__Outputs(this);
  }
}

export class DoAuctionsCall__Inputs {
  _call: DoAuctionsCall;

  constructor(call: DoAuctionsCall) {
    this._call = call;
  }
}

export class DoAuctionsCall__Outputs {
  _call: DoAuctionsCall;

  constructor(call: DoAuctionsCall) {
    this._call = call;
  }

  get value0(): i32 {
    return this._call.outputValues[0].value.toI32();
  }
}

export class FromBUsCall extends ethereum.Call {
  get inputs(): FromBUsCall__Inputs {
    return new FromBUsCall__Inputs(this);
  }

  get outputs(): FromBUsCall__Outputs {
    return new FromBUsCall__Outputs(this);
  }
}

export class FromBUsCall__Inputs {
  _call: FromBUsCall;

  constructor(call: FromBUsCall) {
    this._call = call;
  }

  get BUs(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class FromBUsCall__Outputs {
  _call: FromBUsCall;

  constructor(call: FromBUsCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class IssueCall extends ethereum.Call {
  get inputs(): IssueCall__Inputs {
    return new IssueCall__Inputs(this);
  }

  get outputs(): IssueCall__Outputs {
    return new IssueCall__Outputs(this);
  }
}

export class IssueCall__Inputs {
  _call: IssueCall;

  constructor(call: IssueCall) {
    this._call = call;
  }

  get issuance(): IssueCallIssuanceStruct {
    return changetype<IssueCallIssuanceStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }
}

export class IssueCall__Outputs {
  _call: IssueCall;

  constructor(call: IssueCall) {
    this._call = call;
  }
}

export class IssueCallIssuanceStruct extends ethereum.Tuple {
  get vault(): Address {
    return this[0].toAddress();
  }

  get amount(): BigInt {
    return this[1].toBigInt();
  }

  get BUs(): BigInt {
    return this[2].toBigInt();
  }

  get deposits(): Array<BigInt> {
    return this[3].toBigIntArray();
  }

  get issuer(): Address {
    return this[4].toAddress();
  }

  get blockAvailableAt(): BigInt {
    return this[5].toBigInt();
  }

  get processed(): boolean {
    return this[6].toBoolean();
  }
}

export class RedeemCall extends ethereum.Call {
  get inputs(): RedeemCall__Inputs {
    return new RedeemCall__Inputs(this);
  }

  get outputs(): RedeemCall__Outputs {
    return new RedeemCall__Outputs(this);
  }
}

export class RedeemCall__Inputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }

  get redeemer(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class RedeemCall__Outputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall extends ethereum.Call {
  get inputs(): RenounceOwnershipCall__Inputs {
    return new RenounceOwnershipCall__Inputs(this);
  }

  get outputs(): RenounceOwnershipCall__Outputs {
    return new RenounceOwnershipCall__Outputs(this);
  }
}

export class RenounceOwnershipCall__Inputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class RenounceOwnershipCall__Outputs {
  _call: RenounceOwnershipCall;

  constructor(call: RenounceOwnershipCall) {
    this._call = call;
  }
}

export class SwitchVaultCall extends ethereum.Call {
  get inputs(): SwitchVaultCall__Inputs {
    return new SwitchVaultCall__Inputs(this);
  }

  get outputs(): SwitchVaultCall__Outputs {
    return new SwitchVaultCall__Outputs(this);
  }
}

export class SwitchVaultCall__Inputs {
  _call: SwitchVaultCall;

  constructor(call: SwitchVaultCall) {
    this._call = call;
  }

  get vault_(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SwitchVaultCall__Outputs {
  _call: SwitchVaultCall;

  constructor(call: SwitchVaultCall) {
    this._call = call;
  }
}

export class SwitchVaultsCall extends ethereum.Call {
  get inputs(): SwitchVaultsCall__Inputs {
    return new SwitchVaultsCall__Inputs(this);
  }

  get outputs(): SwitchVaultsCall__Outputs {
    return new SwitchVaultsCall__Outputs(this);
  }
}

export class SwitchVaultsCall__Inputs {
  _call: SwitchVaultsCall;

  constructor(call: SwitchVaultsCall) {
    this._call = call;
  }

  get defaulting(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }
}

export class SwitchVaultsCall__Outputs {
  _call: SwitchVaultsCall;

  constructor(call: SwitchVaultsCall) {
    this._call = call;
  }
}

export class ToBUsCall extends ethereum.Call {
  get inputs(): ToBUsCall__Inputs {
    return new ToBUsCall__Inputs(this);
  }

  get outputs(): ToBUsCall__Outputs {
    return new ToBUsCall__Outputs(this);
  }
}

export class ToBUsCall__Inputs {
  _call: ToBUsCall;

  constructor(call: ToBUsCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class ToBUsCall__Outputs {
  _call: ToBUsCall;

  constructor(call: ToBUsCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class TransferOwnershipCall extends ethereum.Call {
  get inputs(): TransferOwnershipCall__Inputs {
    return new TransferOwnershipCall__Inputs(this);
  }

  get outputs(): TransferOwnershipCall__Outputs {
    return new TransferOwnershipCall__Outputs(this);
  }
}

export class TransferOwnershipCall__Inputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }

  get newOwner(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class TransferOwnershipCall__Outputs {
  _call: TransferOwnershipCall;

  constructor(call: TransferOwnershipCall) {
    this._call = call;
  }
}

export class UnapproveCollateralCall extends ethereum.Call {
  get inputs(): UnapproveCollateralCall__Inputs {
    return new UnapproveCollateralCall__Inputs(this);
  }

  get outputs(): UnapproveCollateralCall__Outputs {
    return new UnapproveCollateralCall__Outputs(this);
  }
}

export class UnapproveCollateralCall__Inputs {
  _call: UnapproveCollateralCall;

  constructor(call: UnapproveCollateralCall) {
    this._call = call;
  }

  get collateral(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class UnapproveCollateralCall__Outputs {
  _call: UnapproveCollateralCall;

  constructor(call: UnapproveCollateralCall) {
    this._call = call;
  }
}
