# Blockchain user
type User @entity {
  id: ID! #User Address
  address: Bytes!
  tokens: [TokenUser!]! @derivedFrom(field: "user")
  mains: [MainUser!]! @derivedFrom(field: "user")
  records: [Entry!]! @derivedFrom(field: "user")
}

# Main control entity over the protocol, holds all related addresses
# A list of "RTokens" is a list of "Mains"
type Main @entity {
  id: ID! # main contract address
  address: Bytes!
  facade: Bytes
  owner: Bytes! # token owner
  token: Token! # rtoken relationship
  basket: Basket # current basket, could change***
  basketHandler: Bytes
  # staked / stToken is used for insurance
  # RSV is the only RToken without these fields
  staked: BigInt! # amount of stToken staked
  stToken: Token # backing token
}

type MainUser @entity {
  id: ID! # <Main Address>-<User Address>
  main: Main!
  user: User!
  staked: BigInt!
  rewarded: BigInt!
}

# Collateral asset for a given basket
type Collateral @entity {
  id: ID! # <basketAddress>-<tokenAddress>
  basket: Basket! # Related basket id
  token: Token! # Collateral token
  index: Int! # Asset index
}

# RToken basket handler
type BasketHandler @entity {
  id: ID! # address of contract
  main: Main # main module
}

# RToken basket
type Basket @entity {
  id: ID! # tx address when created
  handler: BasketHandler! # Main module
  collaterals: [Collateral!] @derivedFrom(field: "basket") # collateral assets
}

# Tokens
type Token @entity {
  id: ID! #Token contract address
  address: Bytes!
  name: String! # name of the token
  symbol: String! # symbol of the token
  decimals: Int! # number of decimals
  transfersCount: BigInt! #Number of transfers
  holdersCount: BigInt! #Number of holders
  type: TokenType! # type of token ERC20 - RSR - RToken - StakingToken
  main: Main # main for the Token - Only set forstToken and RToken
  apy: Int # token APY for rToken and stRSR
  users: [TokenUser!]! @derivedFrom(field: "token")
  supply: Supply @derivedFrom(field: "token")
  records: [Entry!]! @derivedFrom(field: "token")
}

type TokenUser @entity {
  id: ID! #<Token Address>-<User Address>
  token: Token! # RToken
  user: User! #User
  lastTransferTimestamp: BigInt #Timestamp of the last transaction made by user
  transferCount: BigInt! #Number of transfers
  inTransferCount: BigInt! #Number of income transactions
  outTransferCount: BigInt! #Number of outcome transactions
  balance: BigInt! #User Token Balance
  totalIncome: BigInt! #User Token Income
  totalOutcome: BigInt! #User Token Outcome
}

# Track ERC20 token supply
type Supply @entity {
  id: ID! #Token Symbol
  token: Token! #Token
  changedTimestamp: BigInt #Timestamp of the last supply change (minted/burned)
  minted: BigInt! #Minted Tokens Amount
  burned: BigInt! #Burned Tokens Amount
  total: BigInt! #Total Supply
}

# EVM transaction entity
type Transaction @entity {
  id: ID! # tx hash
  block: BigInt!
  timestamp: BigInt!
  from: Bytes!
  to: Bytes
}

# System entry for a given token
type Entry @entity {
  id: ID! # id of the entry, it can be specified by the event
  token: Token!
  main: Main!
  user: User!
  transaction: Transaction! # tx related to the entry
  amount: BigInt! # amount of the operation
  stAmount: BigInt # amount corresponding of st token
  type: String! # Type of entry
  status: EntryStatus! # default: Completed
  createdAt: BigInt!
  updatedAt: BigInt
  # transfer specific
  toAddr: User
  # Unstake / issuance specific
  availableAt: BigInt
  completionTxn: Transaction
}

enum EntryStatus {
  Pending
  Canceled
  Completed
}

enum TokenType {
  RToken
  RSR
  StakingToken
  ERC20
}
